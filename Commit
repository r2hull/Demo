package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantEmailDto;
import com.epay.merchant.entity.KeyManagement;
import com.epay.merchant.entity.MerchantInfo;
import com.epay.merchant.entity.NotificationManagement;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.externalservice.KmsClient;
import com.epay.merchant.externalservice.response.KMSAPIKeysResponse;
import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.repository.KeyRepository;
import com.epay.merchant.repository.NotificationManagementRepository;
import com.epay.merchant.util.EmailUtil;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.KeyType;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.NotificationEntityType;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class KeyDaoTest {

    @InjectMocks
    private KeyDao keyDao;

    @Mock
    private KmsClient kmsClient;

    @Mock
    private KeyRepository keyRepository;

    @Mock
    private MerchantConfig merchantConfig;

    @Mock
    private NotificationDao notificationDao;

    @Mock
    private MerchantInfoDao merchantInfoDao;

    @Mock
    private NotificationManagementRepository notificationManagementRepository;

    private static final String MID = "testMerchant";
    private static final UUID KEY_ID = UUID.randomUUID();
    private KeyGenerationRequest keyGenerationRequest;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        keyGenerationRequest = KeyGenerationRequest.builder().mId("mid").build();
    }

    @Test
    void testGenerateApiKey_Success() {
        List<KMSAPIKeysResponse> apiKeysResponse = Collections.singletonList(KMSAPIKeysResponse.builder().id(KEY_ID).build());
        MerchantResponse<KMSAPIKeysResponse> merchantResponse = MerchantResponse.<KMSAPIKeysResponse>builder()
                .data(apiKeysResponse)
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .build();

        when(kmsClient.generateAPIKeys(anyString(), anyInt())).thenReturn(merchantResponse);
        when(keyRepository.save(any(KeyManagement.class))).thenReturn(KeyManagement.builder().id(KEY_ID).build());

        KMSAPIKeysResponse response = keyDao.generateApiKey(MID);

        assertNotNull(response);
        assertEquals(KEY_ID, response.getId());
        verify(kmsClient, times(1)).generateAPIKeys(anyString(), anyInt());
        verify(keyRepository, times(1)).save(any(KeyManagement.class));
    }

    @Test
    void testGenerateApiKey_RESPONSE_FAILURE() {
        MerchantResponse<KMSAPIKeysResponse> merchantResponse = MerchantResponse.<KMSAPIKeysResponse>builder()
                .data(Collections.singletonList(KMSAPIKeysResponse.builder().id(KEY_ID).build()))
                .status(MerchantConstant.RESPONSE_FAILURE)
                .errors(Collections.singletonList(ErrorDto.builder().errorMessage("Error").build()))
                .build();

        when(kmsClient.generateAPIKeys(anyString(), anyInt())).thenReturn(merchantResponse);

        MerchantException exception = assertThrows(MerchantException.class, () -> keyDao.generateApiKey(MID));
        assertEquals("API Key generation failed.", exception.getMessage());
    }

    @Test
    void testSaveNotification() {
        KeyType keyType = KeyType.API;
        MerchantInfo merchantInfo = MerchantInfo.builder().id(KEY_ID).build();
        String content = "Rahul";
        MerchantEmailDto merchantEmailDto = MerchantEmailDto.builder()
                .toEmail("abc@gmail.com")
                .content(EmailUtil.generateDefaultContent(content))
                .build();
        NotificationManagement notificationMgmt = NotificationManagement.builder()
                .requestType(keyType.name())
                .entityId(KEY_ID)
                .entityName(NotificationEntityType.KEY_MANAGEMENT)
                .build();

        when(merchantInfoDao.getMerchantByMIdAndStatus(MID, MerchantStatus.ACTIVE.name())).thenReturn(merchantInfo);
        doNothing().when(notificationDao).sendEmailNotification(merchantEmailDto, notificationMgmt);

        keyDao.saveNotification(keyType, KEY_ID, content, MID);

        verify(merchantInfoDao, times(1)).getMerchantByMIdAndStatus(MID, MerchantStatus.ACTIVE.name());
    }

    @ParameterizedTest
    @ValueSource(strings = {MID})
    void testGetMerchantEncryptionKeys(String mId) {
        List<KMSEncryptionKeysResponse> kmsEncryptionKeysResponses = Collections.singletonList(
                KMSEncryptionKeysResponse.builder().kek("kek").mek("mek").id(KEY_ID).build());
        MerchantResponse<KMSEncryptionKeysResponse> merchantResponse = MerchantResponse.<KMSEncryptionKeysResponse>builder()
                .data(kmsEncryptionKeysResponses)
                .build();

        when(kmsClient.getEncryptionKeys(mId)).thenReturn(merchantResponse);

        MerchantResponse<KMSEncryptionKeysResponse> merchantEncryptionKeys = keyDao.getMerchantEncryptionKeys(mId);
        assertNotNull(merchantEncryptionKeys.getData());
    }

    @Test
    void testValidatedAPIKey_Success() {
        APIKeyValidationRequest apiKeyValidationRequest = APIKeyValidationRequest.builder()
                .apiKeySecret("apiKeySecret")
                .apiKey("apiKey")
                .build();

        List<String> keys = Arrays.asList("mek", "kek");
        MerchantResponse<String> merchantResponse = MerchantResponse.<String>builder()
                .data(keys)
                .status(1)
                .build();

        when(kmsClient.validatedMerchantKeys(apiKeyValidationRequest)).thenReturn(merchantResponse);
        when(merchantInfoDao.isExistsByMIdAndStatus(anyString(), eq(MerchantStatus.ACTIVE.name()))).thenReturn(true);

        boolean isValid = merchantInfoDao.isExistsByMIdAndStatus(MID, MerchantStatus.ACTIVE.name());
        MerchantResponse<String> stringMerchantResponse = keyDao.validatedAPIKey(apiKeyValidationRequest);

        assertTrue(isValid);
        assertNotNull(stringMerchantResponse.getData());
        verify(merchantInfoDao, times(1)).isExistsByMIdAndStatus(MID, MerchantStatus.ACTIVE.name());
    }

    @Test
    void testValidatedAPIKey_Exception() {
        APIKeyValidationRequest apiKeyValidationRequest = APIKeyValidationRequest.builder()
                .apiKeySecret("apiKeySecret")
                .apiKey("apiKey")
                .build();

        when(merchantInfoDao.isExistsByMIdAndStatus(anyString(), eq(MerchantStatus.ACTIVE.name()))).thenReturn(false);

        MerchantException exception = assertThrows(MerchantException.class, () -> keyDao.validatedAPIKey(apiKeyValidationRequest));
        assertEquals(ErrorConstants.INVALID_ERROR_CODE, exception.getErrorCode());
    }

    @Test
    void testGenerateEncryptionKey_RESPONSE_SUCCESS() {
        List<String> keysResponse = Arrays.asList("mek", "kek");
        MerchantResponse<String> merchantResponse = MerchantResponse.<String>builder()
                .data(keysResponse)
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .build();

        when(kmsClient.generateEncryptionKeys(keyGenerationRequest.getMId(), keyGenerationRequest.getOldKeyExpiryInHr(), merchantConfig.getEncryptionKeyExpiryTime()))
                .thenReturn(merchantResponse);

        when(keyRepository.save(any(KeyManagement.class))).thenReturn(KeyManagement.builder().id(KEY_ID).build());

        KMSEncryptionKeysResponse kmsEncryptionKeysResponse = keyDao.generateEncryptionKey(keyGenerationRequest);
        assertNotNull(kmsEncryptionKeysResponse);
    }

    @Test
    void testGenerateEncryptionKey_RESPONSE_FAILURE() {
        List<String> keysResponse = Arrays.asList("mek", "kek");
        List<ErrorDto> errorDtos = Collections.singletonList(ErrorDto.builder().errorMessage("FAILURE").build());
        MerchantResponse<String> merchantResponse = MerchantResponse.<String>builder()
                .data(keysResponse)
                .status(MerchantConstant.RESPONSE_FAILURE)
                .errors(errorDtos)
                .build();

        when(kmsClient.generateEncryptionKeys(keyGenerationRequest.getMId(), keyGenerationRequest.getOldKeyExpiryInHr(), merchantConfig.getEncryptionKeyExpiryTime()))
                .thenReturn(merchantResponse);

        MerchantException exception = assertThrows(MerchantException.class, () -> keyDao.generateEncryptionKey(keyGenerationRequest));
        assertEquals("API Key generation failed.", exception.getMessage());
    }
}