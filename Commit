import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.data.RepositoryItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableBatchProcessing
public class ReportScheduleManagementJobConfig {

    @Autowired
    private ReportScheduleManagementService reportScheduleManagementService;
    @Autowired
    private ReportScheduleManagementRepository reportScheduleManagementRepository;
    @Autowired
    private ReportManagementDao reportManagementDao;
    @Autowired
    private JobRepository jobRepository;
    @Autowired
    private PlatformTransactionManager transactionManager;

    @Bean
    public Job reportScheduleJob() {
        return new JobBuilder("reportScheduleJob", jobRepository)
                .start(findAndScheduleReports())
                .next(generateReports(reportReader(), reportProcessor(), reportWriter()))
                .build();
    }

    @Bean
    public Step findAndScheduleReports() {
        return new StepBuilder("findAndScheduleReports", jobRepository)
                .tasklet((contribution, chunkContext) -> {
                    // Call your existing method to find reports based on schedule
                    List<ReportScheduleManagement> reports = reportScheduleManagementService.findReportsToSchedule();
                    // Set the reports on the chunkContext for access in the next step (if needed)
                    chunkContext.setAttribute("scheduledReports", reports);
                    return org.springframework.batch.repeat.RepeatStatus.FINISHED;
                }, transactionManager)
                .build();
    }

    @Bean
    public Step generateReports(ItemReader<ReportScheduleManagement> reader,
                                ItemProcessor<ReportScheduleManagement, ReportManagement> processor,
                                ItemWriter<ReportManagement> writer) {

        return new StepBuilder("generateReports", jobRepository)
                .<ReportScheduleManagement, ReportManagement>chunk(10, transactionManager) //Chunk size and transaction manager
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .build();
    }

    @Bean
    public RepositoryItemReader<ReportScheduleManagement> reportReader() {
        RepositoryItemReader<ReportScheduleManagement> reader = new RepositoryItemReader<>();
        reader.setRepository(reportScheduleManagementRepository);
        reader.setMethodName("findByStatusAndNextScheduleExecutionTime");
        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("status", ReportScheduledStatus.TO_BE_START);
        queryParams.put("currentTime", DateTimeUtils.getCurrentTimeInMills());
        queryParams.put("endTime", DateTimeUtils.addMinutes(reportingConfig.getReportScheduleExecutionWindow()));
        reader.setQueryMethodArguments(new Object[]{ReportScheduledStatus.TO_BE_START, DateTimeUtils.getCurrentTimeInMills(), DateTimeUtils.addMinutes(reportingConfig.getReportScheduleExecutionWindow())});
        reader.setPageSize(10);
        reader.setSort(Map.of("id", Sort.Direction.ASC));
        return reader;
    }

    @Bean
    public ItemProcessor<ReportScheduleManagement, ReportManagement> reportProcessor() {
        return item -> ReportManagement.builder().reportId(item.getReportId()).mId(item.getMId()).format(item.getFormat()).scheduledId(item.getId()).durationFromDate(DateTimeUtils.calculateBackDateByFrequency(item.getFrequency(), DateTimeUtils.addMinutes(reportingConfig.getReportScheduleExecutionWindow()))).durationToDate(DateTimeUtils.getCurrentTimeInMills()).scheduledId(item.getId()).status(ReportStatus.TO_BE_GENERATE).build();

    }

    @Bean
    public ItemWriter<ReportManagement> reportWriter() {
        return items -> reportManagementDao.saveAll(items);
    }
}