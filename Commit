package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantEmailDto;
import com.epay.merchant.entity.KeyManagement;
import com.epay.merchant.entity.MerchantInfo;
import com.epay.merchant.entity.NotificationManagement;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.externalservice.KmsClient;
import com.epay.merchant.externalservice.response.KMSAPIKeysResponse;
import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.externalservice.response.KMSKeyResponse;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.repository.KeyRepository;
import com.epay.merchant.repository.NotificationManagementRepository;
import com.epay.merchant.util.EmailUtil;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.KeyType;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.NotificationEntityType;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class KeyDaoTest {

    @InjectMocks
    private KeyDao keyDao;

    @Mock
    private KmsClient kmsClient;

    @Mock
    private KeyRepository keyRepository;

    @Mock
    private MerchantConfig merchantConfig;

    @Mock
    private NotificationDao notificationDao;

    @Mock
    private MerchantInfoDao merchantInfoDao;

    @Mock
    NotificationManagementRepository notificationManagementRepository;

    private static final String MID = "testMerchant";
    private static final UUID KEY_ID = UUID.randomUUID();
    private static final String ERROR_MESSAGE = "API Key generation failed.";
    private KeyGenerationRequest keyGenerationRequest;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        keyGenerationRequest = KeyGenerationRequest.builder().mId("mid").build();
    }

    // Helper method to create a MerchantResponse
    private <T> MerchantResponse<T> createMerchantResponse(List<T> data, int status, List<ErrorDto> errors) {
        return MerchantResponse.<T>builder()
                .data(data)
                .status(status)
                .errors(errors)
                .build();
    }

    @Test
    void testGenerateApiKey_Success() {
        List<KMSAPIKeysResponse> apiKeysResponse = List.of(KMSAPIKeysResponse.builder().id(KEY_ID).build());
        MerchantResponse<KMSAPIKeysResponse> merchantResponse = createMerchantResponse(apiKeysResponse, MerchantConstant.RESPONSE_SUCCESS, null);

        when(kmsClient.generateAPIKeys(anyString(), anyInt())).thenReturn(merchantResponse);
        when(keyRepository.save(any(KeyManagement.class))).thenReturn(KeyManagement.builder().id(KEY_ID).build());

        KMSAPIKeysResponse response = keyDao.generateApiKey(MID);

        assertNotNull(response);
        assertEquals(KEY_ID, response.getId());
        verify(kmsClient, times(1)).generateAPIKeys(anyString(), anyInt());
        verify(keyRepository, times(1)).save(any(KeyManagement.class));
    }

    @Test
    void testGenerateApiKey_Failure() {
        MerchantResponse<KMSAPIKeysResponse> merchantResponse = createMerchantResponse(
                null,
                MerchantConstant.RESPONSE_FAILURE,
                List.of(ErrorDto.builder().errorMessage("Error").build())
        );

        when(kmsClient.generateAPIKeys(anyString(), anyInt())).thenReturn(merchantResponse);

        MerchantException exception = assertThrows(MerchantException.class, () -> keyDao.generateApiKey(MID));
        assertEquals(ERROR_MESSAGE, exception.getMessage());
    }

    @Test
    void testSaveNotification() {
        KeyType keyType = KeyType.API;
        MerchantInfo merchantInfo = MerchantInfo.builder().id(KEY_ID).build();
        String content = "Rahul";
        MerchantEmailDto merchantEmailDto = MerchantEmailDto.builder().toEmail("abc@gmail.com").content(EmailUtil.generateDefaultContent(content)).build();
        NotificationManagement notificationMgmt = NotificationManagement.builder()
                .requestType(keyType.name())
                .entityId(KEY_ID)
                .entityName(NotificationEntityType.KEY_MANAGEMENT)
                .build();

        when(merchantInfoDao.getMerchantByMIdAndStatus(MID, MerchantStatus.ACTIVE.name())).thenReturn(merchantInfo);
        doNothing().when(notificationDao).sendEmailNotification(merchantEmailDto, notificationMgmt);

        keyDao.saveNotification(keyType, KEY_ID, content, MID);

        verify(merchantInfoDao, times(1)).getMerchantByMIdAndStatus(MID, MerchantStatus.ACTIVE.name());
    }

    @ParameterizedTest
    @ValueSource(strings = {MID})
    void testGetMerchantEncryptionKeys(String mId) {
        List<KMSEncryptionKeysResponse> kmsEncryptionKeysResponses = List.of(KMSEncryptionKeysResponse.builder().kek("kek").mek("mek").id(KEY_ID).build());
        MerchantResponse<KMSEncryptionKeysResponse> merchantResponse = createMerchantResponse(kmsEncryptionKeysResponses, MerchantConstant.RESPONSE_SUCCESS, null);

        when(kmsClient.getEncryptionKeys(mId)).thenReturn(merchantResponse);

        MerchantResponse<KMSEncryptionKeysResponse> merchantEncryptionKeys = keyDao.getMerchantEncryptionKeys(mId);

        assertNotNull(merchantEncryptionKeys.getData());
    }

    @Test
    void testValidatedAPIKey_Success() {
        APIKeyValidationRequest apiKeyValidationRequest = APIKeyValidationRequest.builder().apiKeySecret("apiKeySecret").apiKey("apiKey").build();
        MerchantResponse<String> merchantResponse = createMerchantResponse(List.of("mek", "kek"), MerchantConstant.RESPONSE_SUCCESS, null);

        when(kmsClient.validatedMerchantKeys(apiKeyValidationRequest)).thenReturn(merchantResponse);
        when(merchantInfoDao.isExistsByMIdAndStatus(anyString(), eq(MerchantStatus.ACTIVE.name()))).thenReturn(true);

        MerchantResponse<String> stringMerchantResponse = keyDao.validatedAPIKey(apiKeyValidationRequest);

        assertNotNull(stringMerchantResponse.getData());
        verify(merchantInfoDao, times(1)).isExistsByMIdAndStatus(MID, MerchantStatus.ACTIVE.name());
    }

    @Test
    void testValidatedAPIKey_Exception() {
        APIKeyValidationRequest apiKeyValidationRequest = APIKeyValidationRequest.builder().apiKeySecret("apiKeySecret").apiKey("apiKey").build();

        when(merchantInfoDao.isExistsByMIdAndStatus(anyString(), eq(MerchantStatus.ACTIVE.name()))).thenReturn(false);

        MerchantException exception = assertThrows(MerchantException.class, () -> keyDao.validatedAPIKey(apiKeyValidationRequest));

        assertEquals(ErrorConstants.INVALID_ERROR_CODE, exception.getErrorCode());
    }
}