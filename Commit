import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Service
@RequiredArgsConstructor
public class CaptchaService {

    private final CaptchaDao captchaDao;
    private final DefaultKaptcha captchaProducer;
    private final CaptchaValidator captchaValidator;
    private final CaptchaMapper captchaMapper;
    
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    // Executor for async tasks
    private final ExecutorService executorService = Executors.newFixedThreadPool(3);

    public MerchantResponse<CaptchaResponse> generateCaptcha(CaptchaRequest captchaRequest) {
        logger.info("generate captcha for RequestId: {}", captchaRequest.getRequestId());
        return saveCaptcha(captchaRequest, false);
    }

    public MerchantResponse<CaptchaResponse> regenerateCaptcha(CaptchaRequest captchaRequest) {
        logger.info("regenerate captcha for RequestId: {}", captchaRequest.getRequestId());
        captchaValidator.regenerateValidator(captchaRequest);
        return saveCaptcha(captchaRequest, true);
    }

    private MerchantResponse<CaptchaResponse> saveCaptcha(CaptchaRequest captchaRequest, boolean retry) {
        RequestType requestType = RequestType.getRequestType(captchaRequest.getRequestType());
        String captchaText = captchaProducer.createText();
        UUID requestId = captchaRequest.getRequestId();

        // Execute tasks asynchronously
        CompletableFuture<String> imageFuture = CompletableFuture.supplyAsync(() -> generateCaptchaImage(captchaText), executorService);
        CompletableFuture<String> audioFuture = CompletableFuture.supplyAsync(() -> generateCaptchaAudio(captchaText, requestId), executorService);
        CompletableFuture<CaptchaDto> saveFuture = CompletableFuture.supplyAsync(() -> captchaDao.save(captchaText, requestId, requestType, retry), executorService);

        // Combine all async tasks
        CompletableFuture<MerchantResponse<CaptchaResponse>> responseFuture = 
            CompletableFuture.allOf(imageFuture, audioFuture, saveFuture)
                .thenApply(v -> {
                    try {
                        String base64Image = imageFuture.get();
                        String base64Audio = audioFuture.get();
                        CaptchaDto captchaDto = saveFuture.get();
                        return MerchantResponse.<CaptchaResponse>builder()
                            .data(List.of(captchaMapper.mapCaptchaDtoToCaptchaResponse(captchaDto, base64Image, base64Audio)))
                            .status(RESPONSE_SUCCESS)
                            .build();
                    } catch (Exception e) {
                        logger.error("Error in parallel execution", e);
                        return MerchantResponse.<CaptchaResponse>builder().status("ERROR").build();
                    }
                });

        return responseFuture.join(); // Blocking call to return result
    }

    private String generateCaptchaImage(String captchaText) {
        logger.info("Generating captcha image for text: {}", captchaText);
        BufferedImage image = captchaProducer.createImage(captchaText);
        return MerchantUtil.convertImageToBase64(image, "Captcha");
    }

    public String generateCaptchaAudio(String captchaText, UUID requestId) {
        logger.info("Generating captcha audio for requestId: {}", requestId);
        return Optional.ofNullable(captchaText)
                .map(text -> VoiceCaptchaUtil.generateAudioCaptcha(text, requestId))
                .map(data -> VoiceCaptchaUtil.encodeToBase64(data, requestId))
                .orElseGet(() -> {
                    logger.warn("Captcha text is null for requestId: {}", requestId);
                    return "";
                });
    }
}