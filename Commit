import com.epay.merchant.dao.KeyDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.entity.KeyManagement;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.exception.ValidationException;
import com.epay.merchant.externalservice.KmsClient;
import com.epay.merchant.externalservice.response.KMSEncryptionKeysResponse;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.util.MerchantConstant;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.Collections;
import java.util.UUID;

@ExtendWith(MockitoExtension.class)
class KeyDaoTest {

    @Mock
    private KmsClient kmsClient;

    @InjectMocks
    private KeyDao keyDao;

    private KeyGenerationRequest keyGenerationRequest;

    @BeforeEach
    void setUp() {
        keyGenerationRequest = KeyGenerationRequest.builder()
                .mId("merchant123")
                .oldKeyExpiryInHr(24)
                .build();
    }

    @Test
    void testGenerateEncryptionKey_Success() {
        // Arrange
        String generatedKey = "mocked-encryption-key";
        UUID expectedKeyId = UUID.randomUUID();
        when(kmsClient.generateEncryptionKeys(anyString(), anyInt(), anyInt()))
                .thenReturn(MerchantConstant.responseSuccess(Collections.singletonList(generatedKey)));
        when(keyDao.saveKey(anyString(), any(), anyInt(), anyString()))
                .thenReturn(expectedKeyId);

        // Act
        KMSEncryptionKeysResponse response = keyDao.generateEncryptionKey(keyGenerationRequest);

        // Assert
        assertNotNull(response);
        assertEquals(expectedKeyId, response.getId());
        assertEquals(generatedKey, response.getMek());
        verify(kmsClient, times(1)).generateEncryptionKeys(anyString(), anyInt(), anyInt());
    }

    @Test
    void testGenerateEncryptionKey_ValidationException() {
        // Arrange
        ErrorDto error = new ErrorDto("ERR001", "Validation failed");
        when(kmsClient.generateEncryptionKeys(anyString(), anyInt(), anyInt()))
                .thenReturn(MerchantConstant.responseFailure(Collections.singletonList(error)));

        // Act & Assert
        ValidationException exception = assertThrows(ValidationException.class, () -> 
            keyDao.generateEncryptionKey(keyGenerationRequest)
        );
        assertTrue(exception.getErrors().contains(error));
        verify(kmsClient, times(1)).generateEncryptionKeys(anyString(), anyInt(), anyInt());
    }

    @Test
    void testGenerateEncryptionKey_MerchantException() {
        // Arrange
        when(kmsClient.generateEncryptionKeys(anyString(), anyInt(), anyInt()))
                .thenThrow(new RuntimeException("Unexpected error"));

        // Act & Assert
        MerchantException exception = assertThrows(MerchantException.class, () -> 
            keyDao.generateEncryptionKey(keyGenerationRequest)
        );
        assertTrue(exception.getMessage().contains("API Key"));
        verify(kmsClient, times(1)).generateEncryptionKeys(anyString(), anyInt(), anyInt());
    }
}