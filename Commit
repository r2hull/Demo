@Configuration
@EnableBatchProcessing
public class ReportScheduleBatchConfig {

    @Autowired
    private ReportScheduleManagementRepository repository;

    @Autowired
    private ReportManagementDao reportManagementDao;

    @Bean
    public Job reportScheduleJob(JobBuilderFactory jobBuilderFactory, StepBuilderFactory stepBuilderFactory) {
        return jobBuilderFactory.get("reportScheduleJob")
                .start(processReportSchedules(stepBuilderFactory))
                .build();
    }

    @Bean
    public Step processReportSchedules(StepBuilderFactory stepBuilderFactory) {
        return stepBuilderFactory.get("processReportSchedules")
                .<ReportScheduleManagement, ReportManagement>chunk(10)
                .reader(reportScheduleReader(null, null))
                .processor(reportScheduleProcessor())
                .writer(reportManagementWriter())
                .build();
    }

    @Bean
    @StepScope
    public RepositoryItemReader<ReportScheduleManagement> reportScheduleReader(
            @Value("#{jobParameters['startTime']}") Long startTime,
            @Value("#{jobParameters['endTime']}") Long endTime) {

        return new RepositoryItemReaderBuilder<ReportScheduleManagement>()
                .repository(repository)
                .methodName("findByStatusAndNextScheduleExecutionTime")
                .arguments(ReportScheduledStatus.TO_BE_START, startTime, endTime)
                .sorts(Collections.singletonMap("nextScheduleExecutionTime", Sort.Direction.ASC))
                .build();
    }

    @Bean
    public ItemProcessor<ReportScheduleManagement, ReportManagement> reportScheduleProcessor() {
        return schedule -> {
            schedule.setLastScheduleExecutionTime(System.currentTimeMillis());
            return ReportManagement.builder()
                    .reportId(schedule.getReportId())
                    .mId(schedule.getMId())
                    .format(schedule.getFormat())
                    .scheduledId(schedule.getId())
                    .durationFromDate(DateTimeUtils.calculateBackDateByFrequency(schedule.getFrequency(), System.currentTimeMillis()))
                    .durationToDate(System.currentTimeMillis())
                    .status(ReportStatus.TO_BE_GENERATE)
                    .build();
        };
    }

    @Bean
    public ItemWriter<ReportManagement> reportManagementWriter() {
        return items -> {
            reportManagementDao.saveAll(items);
            System.out.println("Processed and saved " + items.size() + " reports.");
        };
    }
}