import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

private MerchantResponse<CaptchaResponse> saveCaptcha(CaptchaRequest captchaRequest, boolean retry) {
    RequestType requestType = RequestType.getRequestType(captchaRequest.getRequestType());

    // Step 1: Generate Captcha Text
    String captchaText = captchaProducer.createText();

    // Step 2: Execute image, audio, and DB save tasks reactively
    Mono<String> imageMono = Mono.fromCallable(() -> generateCaptchaImage(captchaText))
                                 .subscribeOn(Schedulers.boundedElastic()); // Run in a non-blocking thread pool

    Mono<String> audioMono = Mono.fromCallable(() -> generateCaptchaAudio(captchaText, captchaRequest.getRequestId()))
                                 .subscribeOn(Schedulers.boundedElastic());

    Mono<CaptchaDto> captchaSaveMono = Mono.fromCallable(() -> 
        captchaDao.save(captchaText, captchaRequest.getRequestId(), requestType, retry))
                                 .subscribeOn(Schedulers.boundedElastic());

    // Step 3: Combine results and block (since the controller is not reactive)
    return Mono.zip(imageMono, audioMono, captchaSaveMono)
            .map(tuple -> {
                String base64Image = tuple.getT1();
                String base64Audio = tuple.getT2();
                CaptchaDto captchaDto = tuple.getT3();

                logger.info("Captcha generation completed for RequestId: {}", captchaRequest.getRequestId());

                return MerchantResponse.<CaptchaResponse>builder()
                        .data(List.of(captchaMapper.mapCaptchaDtoToCaptchaResponse(captchaDto, base64Image, base64Audio)))
                        .status(RESPONSE_SUCCESS)
                        .build();
            })
            .block();  // Blocking here since the controller is non-reactive
}