package com.epay.merchant.util;

import com.epay.merchant.exception.MerchantException;
import com.sun.speech.freetts.Voice;
import com.sun.speech.freetts.VoiceManager;
import com.sun.speech.freetts.audio.SingleFileAudioPlayer;
import lombok.experimental.UtilityClass;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.sound.sampled.AudioFileFormat;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.Base64;
import java.util.Optional;
import java.util.UUID;
/**
 * Class Name: VoiceCaptchaUtil
 * <p>
 * Description: This class provides methods to convert text into speech and generate audio files,
 * returning the result as a byte array.
 * </p>
 * Author: Bhoopendra Rajput
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.1
 */
@UtilityClass
public class VoiceCaptchaUtil {

    private static final Logger logger = LoggerFactory.getLogger(VoiceCaptchaUtil.class);
    private static final String VOICE_NAME = "kevin16";
    private static final int SLEEP_TIME = 10;

    static {
        System.setProperty("freetts.voices", "com.sun.speech.freetts.en.us.cmu_us_kal.KevinVoiceDirectory");
    }

    /**
     * Converts the given text into speech and returns the generated audio as a byte array.
     *
     * @param text      The input text to be converted into speech.
     * @param requestId Unique identifier for tracking requests.
     * @return Byte array containing the generated speech audio.
     */
    public static byte[] generateAudioCaptcha(String text, UUID requestId) {
        logger.info("Generating audio captcha for requestId: {}", requestId);
        File tempFile = createTempFile(requestId);
        if (tempFile == null){
            logger.error("Temp file creation failed for requestId: {}", requestId);
            return new byte[0];
        }

        try {
            Voice voice = initializeVoice();
            if (voice == null) {
                logger.error("Voice initialization failed for requestId: {}", requestId);
                return new byte[0];
            }

            SingleFileAudioPlayer audioPlayer = configureAudioPlayer(tempFile);
            voice.setAudioPlayer(audioPlayer);

            speakCharacters(voice, text);
            cleanupResources(voice, audioPlayer);

            return validateAndReturnAudio(tempFile, requestId);
        } catch (Exception e) {
            logger.error("Error generating speech audio for requestId: {}", requestId, e);
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE,
                    MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, requestId));
        } finally {
            deleteTempFile(tempFile);
        }
    }

    /**
     * Creates a temporary file for storing the generated audio.
     *
     * @param requestId Unique identifier for the request.
     * @return A File object representing the temporary file.
     */
    private static File createTempFile(UUID requestId) {
        try {
            File tempFile = File.createTempFile("speech_" + System.currentTimeMillis() + "_" + requestId, ".wav");
            tempFile.deleteOnExit();
            logger.debug("Temporary file created: {}", tempFile.getAbsolutePath());
            return tempFile;
        } catch (IOException e) {
            logger.error("Failed to create temp file for requestId: {}", requestId, e);
            return null;
        }
    }

    /**
     * Initializes the voice engine with predefined settings.
     *
     * @return A Voice object if successful, otherwise null.
     */
    private static Voice initializeVoice() {
        VoiceManager voiceManager = VoiceManager.getInstance();
        Voice voice = voiceManager.getVoice(VOICE_NAME);
        if (voice == null) {
            logger.error("Voice '{}' not found.", VOICE_NAME);
            return null;
        }
        voice.allocate();
        voice.setRate(130);
        voice.setPitch(100);
        voice.setVolume(1.0f);

        logger.debug("Voice '{}' initialized successfully.", VOICE_NAME);
        return voice;
    }

    /**
     * Configures the audio player for generating speech output.
     *
     * @param tempFile Temporary file to store the audio.
     * @return Configured SingleFileAudioPlayer instance.
     */
    private static SingleFileAudioPlayer configureAudioPlayer(File tempFile) {
        return new SingleFileAudioPlayer(tempFile.getAbsolutePath().replace(".wav", ""), AudioFileFormat.Type.WAVE);
    }

    /**
     * Converts each character in the given text into speech.
     *
     * @param voice The initialized voice object.
     * @param text  The text to be spoken.
     */
    private static void speakCharacters(Voice voice, String text) {
        logger.debug("Speaking text: {}", text);
        text.chars()
                .mapToObj(c -> String.valueOf((char) c))
                .filter(ch -> ch.matches("[a-zA-Z0-9]"))
                .forEach(ch -> {
                    voice.speak(ch);
                    sleep();
                });
    }

    /**
     * Cleans up the resources used by the voice engine.
     *
     * @param voice       The Voice object to be deallocated.
     * @param audioPlayer The AudioPlayer instance to be closed.
     */
    private static void cleanupResources(Voice voice, SingleFileAudioPlayer audioPlayer) {
        voice.deallocate();
        audioPlayer.close();
        logger.debug("Resources cleaned up successfully.");
    }

    /**
     * Validates the generated audio file and converts it into a byte array.
     *
     * @param tempFile  The generated audio file.
     * @param requestId Unique request identifier.
     * @return Byte array containing the audio file data.
     */
    private static byte[] validateAndReturnAudio(File tempFile, UUID requestId) {
        if (!tempFile.exists() || tempFile.length() == 0) {
            logger.error("Generated audio file is empty or missing for requestId: {}", requestId);
            return new byte[0];
        }
        logger.info("Audio file successfully generated for requestId: {}", requestId);
        return fileToByteArray(tempFile);
    }


    /**
     * Deletes the temporary file after use.
     *
     * @param tempFile The file to be deleted.
     */
    private static void deleteTempFile(File tempFile) {
        if (tempFile != null && tempFile.exists() && !tempFile.delete()) {
            logger.warn("Failed to delete temporary file: {}", tempFile.getAbsolutePath());
        }

    }
    /**
     * Sleeps for a specified duration.
     */
    private static void sleep() {
        try {
            Thread.sleep(SLEEP_TIME);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.warn("Sleep interrupted", e);
        }
    }

    /**
     * Reads the contents of a file and returns it as a byte array.
     *
     * @param file The file to read.
     * @return Byte array containing the file contents.
     */
    private static byte[] fileToByteArray(File file) {
        try (FileInputStream fis = new FileInputStream(file);
             ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {

            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                byteArrayOutputStream.write(buffer, 0, bytesRead);
            }
            logger.debug("File successfully converted to byte array: {}", file.getAbsolutePath());
            return byteArrayOutputStream.toByteArray();

        } catch (IOException e) {
            logger.error("Error reading file to byte array: {}", file.getAbsolutePath(), e);
            throw new MerchantException(ErrorConstants.GENERATION_ERROR_CODE,
                    MessageFormat.format(ErrorConstants.GENERATION_ERROR_MESSAGE, file.getName()));
        }
    }

    /**
     * Encodes a byte array to a Base64 string
     *
     * @param data      The byte array to encode.
     * @param requestId The request ID for logging.
     * @return The Base64-encoded string.
     */
    public String encodeToBase64(byte[] data, UUID requestId) {
        return Optional.ofNullable(data)
                .filter(d -> d.length > 0)
                .map(Base64.getEncoder()::encodeToString)
                .orElseGet(() -> {
                    logger.warn("Empty byte array for requestId: {}", requestId);
                    return "";
                });
    }
}
