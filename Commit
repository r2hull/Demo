package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.dto.MerchantEmailDto;
import com.epay.merchant.entity.KeyManagement;
import com.epay.merchant.entity.MerchantInfo;
import com.epay.merchant.entity.NotificationManagement;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.model.request.APIKeyValidationRequest;
import com.epay.merchant.model.request.KeyGenerationRequest;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.repository.KeyRepository;
import com.epay.merchant.repository.NotificationManagementRepository;
import com.epay.merchant.util.EmailUtil;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantConstant;
import com.epay.merchant.util.enums.KeyType;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.NotificationEntityType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class KeyDaoTest {

    @InjectMocks
    private KeyDao keyDao;

    @Mock
    private KmsClient kmsClient;

    @Mock
    private KeyRepository keyRepository;

    @Mock
    private MerchantConfig merchantConfig;

    @Mock
    private NotificationDao notificationDao;

    @Mock
    private MerchantInfoDao merchantInfoDao;

    @Mock
    private NotificationManagementRepository notificationManagementRepository;

    private static final String MID = "testMerchant";
    private static final UUID KEY_ID = UUID.randomUUID();
    private KeyGenerationRequest keyGenerationRequest;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        keyGenerationRequest = KeyGenerationRequest.builder()
                .mId("mid")
                .build();
    }

    // Test API Key Generation (Success)
    @Test
    void testGenerateApiKey_Success() {
        List<KMSAPIKeysResponse> apiKeysResponse = Arrays.asList(KMSAPIKeysResponse.builder().id(KEY_ID).build());
        MerchantResponse<KMSAPIKeysResponse> merchantResponse = MerchantResponse.<KMSAPIKeysResponse>builder()
                .data(apiKeysResponse)
                .status(MerchantConstant.RESPONSE_SUCCESS)
                .build();

        when(kmsClient.generateAPIKeys(anyString(), anyInt())).thenReturn(merchantResponse);
        when(keyRepository.save(any(KeyManagement.class))).thenReturn(KeyManagement.builder().id(KEY_ID).build());

        KMSAPIKeysResponse response = keyDao.generateApiKey(MID);

        assertNotNull(response);
        assertEquals(KEY_ID, response.getId());
        verify(kmsClient, times(1)).generateAPIKeys(anyString(), anyInt());
        verify(keyRepository, times(1)).save(any(KeyManagement.class));
    }

    // Test API Key Generation (Response Failure)
    @Test
    void testGenerateApiKey_ResponseFailure() {
        MerchantResponse<KMSAPIKeysResponse> merchantResponse = MerchantResponse.<KMSAPIKeysResponse>builder()
                .status(MerchantConstant.RESPONSE_FAILURE)
                .errors(List.of(ErrorDto.builder().errorMessage("Error").build()))
                .build();

        when(kmsClient.generateAPIKeys(anyString(), anyInt())).thenReturn(merchantResponse);

        MerchantException exception = assertThrows(MerchantException.class, () -> keyDao.generateApiKey(MID));
        assertEquals("API Key generation failed.", exception.getMessage());
    }

    // Test Notification Saving
    @Test
    void testSaveNotification() {
        KeyType keyType = KeyType.API;
        String content = "Rahul";

        MerchantInfo merchantInfo = MerchantInfo.builder().id(KEY_ID).build();
        MerchantEmailDto merchantEmailDto = MerchantEmailDto.builder()
                .toEmail("abc@gmail.com")
                .content(EmailUtil.generateDefaultContent(content))
                .build();

        NotificationManagement notificationMgmt = NotificationManagement.builder()
                .requestType(keyType.name())
                .entityId(KEY_ID)
                .entityName(NotificationEntityType.KEY_MANAGEMENT)
                .build();

        when(merchantInfoDao.getMerchantByMIdAndStatus(MID, MerchantStatus.ACTIVE.name())).thenReturn(merchantInfo);
        doNothing().when(notificationDao).sendEmailNotification(merchantEmailDto, notificationMgmt);

        keyDao.saveNotification(keyType, KEY_ID, content, MID);

        verify(merchantInfoDao, times(1)).getMerchantByMIdAndStatus(MID, MerchantStatus.ACTIVE.name());
        verify(notificationDao, times(1)).sendEmailNotification(merchantEmailDto, notificationMgmt);
    }

    // Test Get Encryption Keys
    @ParameterizedTest
    @ValueSource(strings = {MID})
    void testGetMerchantEncryptionKeys(String mId) {
        List<KMSEncryptionKeysResponse> kmsEncryptionKeysResponses = List.of(
                KMSEncryptionKeysResponse.builder().kek("kek").mek("mek").id(KEY_ID).build()
        );

        MerchantResponse<KMSEncryptionKeysResponse> merchantResponse = MerchantResponse.<KMSEncryptionKeysResponse>builder()
                .data(kmsEncryptionKeysResponses)
                .build();

        when(kmsClient.getEncryptionKeys(mId)).thenReturn(merchantResponse);

        MerchantResponse<KMSEncryptionKeysResponse> result = keyDao.getMerchantEncryptionKeys(mId);
        assertNotNull(result.getData());
        assertEquals(1, result.getData().size());
    }

    // Test Validate API Key (Success)
    @Test
    void testValidatedAPIKey_Success() {
        APIKeyValidationRequest apiKeyValidationRequest = APIKeyValidationRequest.builder()
                .apiKeySecret("apiKeySecret")
                .apiKey("apiKey")
                .build();

        List<String> list = List.of("mek", "kek");
        MerchantResponse<String> merchantResponse = MerchantResponse.<String>builder()
                .data(list)
                .status(1)
                .build();

        when(kmsClient.validatedMerchantKeys(apiKeyValidationRequest)).thenReturn(merchantResponse);
        when(merchantInfoDao.isExistsByMIdAndStatus(anyString(), eq(MerchantStatus.ACTIVE.name()))).thenReturn(true);

        boolean isValid = merchantInfoDao.isExistsByMIdAndStatus(MID, MerchantStatus.ACTIVE.name());
        MerchantResponse<String> stringMerchantResponse = keyDao.validatedAPIKey(apiKeyValidationRequest);

        assertTrue(isValid);
        assertNotNull(stringMerchantResponse.getData());
        verify(merchantInfoDao, times(1)).isExistsByMIdAndStatus(MID, MerchantStatus.ACTIVE.name());
    }

    // Test Validate API Key (Exception)
    @Test
    void testValidatedAPIKey_Exception() {
        APIKeyValidationRequest apiKeyValidationRequest = APIKeyValidationRequest.builder()
                .apiKeySecret("apiKeySecret")
                .apiKey("apiKey")
                .build();

        when(merchantInfoDao.isExistsByMIdAndStatus(anyString(), eq(MerchantStatus.ACTIVE.name()))).thenReturn(false);

        MerchantException exception = assertThrows(MerchantException.class, () -> keyDao.validatedAPIKey(apiKeyValidationRequest));
        assertEquals(ErrorConstants.INVALID_ERROR_CODE, exception.getErrorCode());
    }
}