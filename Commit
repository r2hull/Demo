package com.epay.reporting.service;

import com.epay.reporting.dao.InvoiceDao;
import com.epay.reporting.dto.InvoiceReportDetailDto;
import com.epay.reporting.exception.ReportingException;
import com.epay.reporting.exception.ValidationException;
import com.epay.reporting.model.request.InvoiceSearchRequest;
import com.epay.reporting.model.response.ReportingResponse;
import com.epay.reporting.util.enums.Report;
import com.epay.reporting.util.enums.ReportFormat;
import com.epay.reporting.util.file.model.FileModel;
import com.epay.reporting.util.file.model.PdfFileModel;
import com.epay.reporting.validator.MIdValidator;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.commons.collections4.CollectionUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.text.MessageFormat;
import java.time.YearMonth;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class InvoiceServiceTest {

    @InjectMocks
    private InvoiceService invoiceService;

    @Mock
    private InvoiceDao invoiceDao;

    @Mock
    private FileGeneratorService fileGeneratorService;

    @Mock
    private MIdValidator mIdValidator;

    @Mock
    private HttpServletResponse response;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testSearchInvoice_Success() {
        // Given
        String mId = "12345";
        InvoiceSearchRequest searchRequest = new InvoiceSearchRequest();
        searchRequest.setMonths(List.of(YearMonth.of(2024, 1), YearMonth.of(2024, 2)));

        // When
        ReportingResponse<InvoiceReportDetailDto> response = invoiceService.searchInvoice(mId, searchRequest);

        // Then
        assertNotNull(response);
        assertEquals(2, response.getData().size());
        assertTrue(response.getData().get(0).isAvailable());
        verify(mIdValidator, times(1)).validatedMId(mId);
    }

    @Test
    void testSearchInvoice_EmptyMonths() {
        // Given
        String mId = "12345";
        InvoiceSearchRequest searchRequest = new InvoiceSearchRequest();
        searchRequest.setMonths(Collections.emptyList());

        // When
        ReportingResponse<InvoiceReportDetailDto> response = invoiceService.searchInvoice(mId, searchRequest);

        // Then
        assertNotNull(response);
        assertEquals(0, response.getData().size());
        verify(mIdValidator, times(1)).validatedMId(mId);
    }

    @Test
    void testGenerateMerchantFeesInvoice_Success_SingleFile() {
        // Given
        String mId = "12345";
        List<String> reportDates = List.of("2024-01");

        Map<String, Object> feesInvoiceData = new HashMap<>();
        feesInvoiceData.put("report", "2024-01");

        when(invoiceDao.getFeesInvoiceData(mId, reportDates)).thenReturn(List.of(feesInvoiceData));

        // When
        ReportingResponse<String> response = invoiceService.generateMerchantFeesInvoice(mId, reportDates, this.response);

        // Then
        assertNotNull(response);
        verify(mIdValidator, times(1)).validatedActiveMId(mId);
        verify(fileGeneratorService, times(1)).downloadFile(any(), eq(ReportFormat.PDF), eq(Report.FEES_INVOICE), eq(mId), any(FileModel.class));
    }

    @Test
    void testGenerateMerchantFeesInvoice_Success_ZipFile() {
        // Given
        String mId = "12345";
        List<String> reportDates = List.of("2024-01", "2024-02");

        Map<String, Object> feesInvoiceData1 = new HashMap<>();
        feesInvoiceData1.put("report", "2024-01");

        Map<String, Object> feesInvoiceData2 = new HashMap<>();
        feesInvoiceData2.put("report", "2024-02");

        when(invoiceDao.getFeesInvoiceData(mId, reportDates)).thenReturn(List.of(feesInvoiceData1, feesInvoiceData2));

        // When
        ReportingResponse<String> response = invoiceService.generateMerchantFeesInvoice(mId, reportDates, this.response);

        // Then
        assertNotNull(response);
        verify(fileGeneratorService, times(1)).zipFileGenerator(any(), eq(ReportFormat.PDF), eq(Report.FEES_INVOICE), eq(mId), anyList());
    }

    @Test
    void testGenerateMerchantFeesInvoice_NoDataFound() {
        // Given
        String mId = "12345";
        List<String> reportDates = List.of("2024-01");

        when(invoiceDao.getFeesInvoiceData(mId, reportDates)).thenReturn(Collections.emptyList());

        // When
        ReportingResponse<String> response = invoiceService.generateMerchantFeesInvoice(mId, reportDates, this.response);

        // Then
        assertNotNull(response);
        assertEquals(List.of("No Data Found"), response.getData());
    }

    @Test
    void testGenerateMerchantFeesInvoice_ValidationException() {
        // Given
        String mId = "12345";
        List<String> reportDates = List.of("2024-01");

        doThrow(new ValidationException("Invalid MID")).when(mIdValidator).validatedActiveMId(mId);

        // When & Then
        assertThrows(ValidationException.class, () -> invoiceService.generateMerchantFeesInvoice(mId, reportDates, this.response));
    }

    @Test
    void testGenerateMerchantFeesInvoice_ReportingException() {
        // Given
        String mId = "12345";
        List<String> reportDates = List.of("2024-01");

        doThrow(new ReportingException("GENERATION_ERROR", "Error generating file")).when(fileGeneratorService).downloadFile(any(), any(), any(), any(), any());

        // When & Then
        assertThrows(ReportingException.class, () -> invoiceService.generateMerchantFeesInvoice(mId, reportDates, this.response));
    }

    @Test
    void testGenerateMerchantFeesInvoice_GeneralException() {
        // Given
        String mId = "12345";
        List<String> reportDates = List.of("2024-01");

        doThrow(new RuntimeException("Unexpected Error")).when(invoiceDao).getFeesInvoiceData(mId, reportDates);

        // When & Then
        Exception exception = assertThrows(ReportingException.class, () -> invoiceService.generateMerchantFeesInvoice(mId, reportDates, this.response));
        assertTrue(exception.getMessage().contains("Failed to generate PDF"));
    }

    @Test
    void testGetFileModels_Success() {
        // Given
        Map<String, Object> feesInvoiceData = new HashMap<>();
        feesInvoiceData.put("report", "2024-01");
        List<Map<String, Object>> feesInvoiceDataList = List.of(feesInvoiceData);

        // When
        List<FileModel> fileModels = invokeGetFileModels(feesInvoiceDataList);

        // Then
        assertEquals(1, fileModels.size());
        assertEquals("2024-01", fileModels.get(0).getReportMonth());
    }

    @Test
    void testGetFileModels_EmptyList() {
        // When
        List<FileModel> fileModels = invokeGetFileModels(Collections.emptyList());

        // Then
        assertTrue(fileModels.isEmpty());
    }

    private List<FileModel> invokeGetFileModels(List<Map<String, Object>> feesInvoiceData) {
        try {
            return (List<FileModel>) InvoiceService.class
                    .getDeclaredMethod("getFileModels", List.class)
                    .invoke(null, feesInvoiceData);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}