@Component
@RequiredArgsConstructor
public class ReportScheduleManagementDao {

    private final ReportScheduleManagementRepository reportScheduleManagementRepository;
    private final Logger log = LoggerFactory.getLogger(ReportScheduleManagementDao.class);

    @Transactional
    public void executeReportBySchedule() {
        Long scheduleStartTime = DateTimeUtils.getCurrentTimeInMills();
        Long scheduleEndTime = DateTimeUtils.addMinutes(reportingConfig.getReportScheduleExecutionWindow());
        
        // Fetch the reports to be processed within the scheduled time window
        List<ReportScheduleManagement> reportScheduleManagementList = findByStatusAndNextScheduleExecutionTime(scheduleStartTime, scheduleEndTime);
        
        int totalSize = reportScheduleManagementList.size();
        int batchSize = 400;  // This should match the batch size configured in application.yml
        int processed = 0;

        for (int i = 0; i < totalSize; i += batchSize) {
            int end = Math.min(i + batchSize, totalSize);
            List<ReportScheduleManagement> batch = reportScheduleManagementList.subList(i, end);
            
            // Perform the batch insert/update here
            reportScheduleManagementRepository.saveAll(batch);
            
            processed += batch.size();
            log.info("Processed {} of {} records", processed, totalSize);  // Log progress after each batch
        }

        // Other logic (e.g., saving associated ReportManagement entities) can go here
        List<ReportManagement> reportManagementList = reportScheduleManagementList.stream().map(schedule -> {
            schedule.setLastScheduleExecutionTime(DateTimeUtils.getCurrentTimeInMills());
            return ReportManagement.builder()
                    .reportId(schedule.getReportId())
                    .mId(schedule.getMId())
                    .format(schedule.getFormat())
                    .scheduledId(schedule.getId())
                    .durationFromDate(DateTimeUtils.calculateBackDateByFrequency(schedule.getFrequency(), scheduleEndTime))
                    .durationToDate(scheduleStartTime)
                    .status(ReportStatus.TO_BE_GENERATE)
                    .build();
        }).toList();
        
        reportManagementDao.saveAll(reportManagementList);
    }
    
    private List<ReportScheduleManagement> findByStatusAndNextScheduleExecutionTime(long scheduleStartTime, long scheduleEndTime) {
        return reportScheduleManagementRepository.findByStatusAndNextScheduleExecutionTime(ReportScheduledStatus.TO_BE_START, scheduleStartTime, scheduleEndTime);
    }
}