@Component
@RequiredArgsConstructor
public class ReportScheduleManagementScheduler {

    private final ReportScheduleManagementService reportScheduleManagementService;

    @Scheduled(cron = "${scheduled.cron.time}") // Cron expression for scheduling
    @SchedulerLock(name = "Report_Scheduler", lockAtLeastFor = "PT30S", lockAtMostFor = "PT2M")
    public void scheduleReportGeneration() {
        reportScheduleManagementService.executeBatchJob();
    }
}







@Service
@RequiredArgsConstructor
public class ReportScheduleManagementService {

    private final JobLauncher jobLauncher;
    private final Job reportScheduleJob;

    public void executeBatchJob() {
        try {
            JobParameters jobParameters = new JobParametersBuilder()
                    .addLong("startTime", System.currentTimeMillis())
                    .toJobParameters();

            // Launch the batch job
            jobLauncher.run(reportScheduleJob, jobParameters);

        } catch (Exception e) {
            System.err.println("Error executing batch job: " + e.getMessage());
        }
    }
}







@Configuration
@RequiredArgsConstructor
public class ReportScheduleBatchConfig {

    private final ReportScheduleManagementRepository reportScheduleManagementRepository;

    @Bean
    public Job reportScheduleJob(JobRepository jobRepository, Step reportScheduleStep) {
        return new JobBuilder("reportScheduleJob", jobRepository)
                .start(reportScheduleStep)
                .build();
    }

    @Bean
    public Step reportScheduleStep(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
        return new StepBuilder("reportScheduleStep", jobRepository)
                .<ReportScheduleManagement, ReportManagement>chunk(10, transactionManager)
                .reader(reportScheduleItemReader())
                .processor(reportScheduleItemProcessor())
                .writer(reportScheduleItemWriter())
                .build();
    }

    @Bean
    public ItemReader<ReportScheduleManagement> reportScheduleItemReader() {
        return new RepositoryItemReaderBuilder<ReportScheduleManagement>()
                .repository(reportScheduleManagementRepository)
                .methodName("findByStatusAndNextScheduleExecutionTime")
                .arguments(List.of(ReportScheduledStatus.TO_BE_START, System.currentTimeMillis(), System.currentTimeMillis() + 30 * 60 * 1000))
                .pageSize(10)
                .build();
    }

    @Bean
    public ItemProcessor<ReportScheduleManagement, ReportManagement> reportScheduleItemProcessor() {
        return schedule -> {
            schedule.setLastScheduleExecutionTime(System.currentTimeMillis());
            return ReportManagement.builder()
                    .reportId(schedule.getReportId())
                    .status(ReportStatus.TO_BE_GENERATE)
                    .build();
        };
    }

    @Bean
    public ItemWriter<ReportManagement> reportScheduleItemWriter() {
        return items -> {
            // Persist processed items
            System.out.println("Writing items: " + items);
        };
    }
}








@Repository
public interface ReportScheduleManagementRepository extends JpaRepository<ReportScheduleManagement, UUID> {

    @Query("SELECT r FROM ReportScheduleManagement r " +
            "WHERE r.status = :status " +
            "AND r.nextScheduleExecutionTime BETWEEN :currentTime AND :endTime")
    List<ReportScheduleManagement> findByStatusAndNextScheduleExecutionTime(
            @Param("status") ReportScheduledStatus status,
            @Param("currentTime") Long currentTime,
            @Param("endTime") Long endTime);
}