public List<MasterValueResponse> getMasterData(String alias, String parentId) {

    // 1️⃣ Check for leading/trailing spaces or invalid chars
    if (alias == null || alias.trim().isEmpty()) {
        throw new InvalidRequestException("Alias must not be blank");
    }
    alias = alias.trim();

    if (!alias.matches("^[A-Z_]+$")) {
        throw new InvalidRequestException("Alias must contain only uppercase alphabets and underscores");
    }

    // 2️⃣ Fetch master by alias
    Master master = masterRepository.findByAlias(alias)
            .orElseThrow(() -> new ResourceNotFoundException("Invalid alias: " + alias));

    // 3️⃣ If parentId is provided → validate logical parent mapping
    if (parentId != null && !parentId.isBlank()) {
        MasterValue parentValue = masterValueRepository.findById(parentId)
                .orElseThrow(() -> new ResourceNotFoundException("Parent ID not found"));

        // check if parentValue belongs to correct master type
        if (!isParentValidForAlias(alias, parentValue.getMaster().getAlias())) {
            throw new InvalidRequestException(
                "Invalid parentId for alias " + alias + ". Expected parent of type " +
                expectedParent(alias) + " but got " + parentValue.getMaster().getAlias()
            );
        }

        return masterValueRepository.findByMasterAndParent(master, parentValue);
    }

    // 4️⃣ If no parentId → just return all values for alias
    return masterValueRepository.findByMaster(master);
}

// helper mapping logic
private boolean isParentValidForAlias(String alias, String parentAlias) {
    switch (alias) {
        case "STATE": return parentAlias.equals("COUNTRY");
        case "CITY": return parentAlias.equals("STATE");
        default: return true; // others don't need parent
    }
}

private String expectedParent(String alias) {
    switch (alias) {
        case "STATE": return "COUNTRY";
        case "CITY": return "STATE";
        default: return "NONE";
    }
}