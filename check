public interface OrderRepository extends JpaRepository<Order, String>, JpaSpecificationExecutor<Order> {
}



@UtilityClass
public class OrderSpecification {

    public static Specification<Order> searchOrder(String mId, MerchantOrderPaymentSearchRequest searchRequest) {
        return (root, query, criteriaBuilder) -> {
            Predicate predicate = criteriaBuilder.conjunction();
            if (StringUtils.isEmpty(mId)) {
                return predicate;
            }
            predicate = criteriaBuilder.and(predicate, getMidPredicate(root, criteriaBuilder, mId));

            if (searchRequest == null) {
                return predicate;
            }

            // Determine if any payment-specific filters are provided (to decide join type)
            boolean hasPaymentFilters = StringUtils.hasText(searchRequest.getAtrn()) ||
                                        StringUtils.hasText(searchRequest.getBankRefNumber()) ||
                                        StringUtils.hasText(searchRequest.getTransactionStatus()) ||
                                        StringUtils.hasText(searchRequest.getRefundStatus()) ||
                                        StringUtils.hasText(searchRequest.getPaymentStatus()) ||
                                        StringUtils.hasText(searchRequest.getOrderRefNumber()) ||  // Assuming orderRefNumber is in payment
                                        ObjectUtils.isNotEmpty(searchRequest.getFromDate()) ||
                                        ObjectUtils.isNotEmpty(searchRequest.getToDate());

            JoinType joinType = hasPaymentFilters ? JoinType.INNER : JoinType.LEFT;

            Join<Order, MerchantOrderPayment> paymentJoin = null;

            // Create join only if needed (for payment filters or orderRefNumber, which is in both but assuming payment)
            if (hasPaymentFilters || StringUtils.hasText(searchRequest.getOrderRefNumber())) {
                paymentJoin = root.join("merchantOrderPayments", joinType);
            }

            if (StringUtils.hasText(searchRequest.getAtrn())) {
                predicate = criteriaBuilder.and(predicate, getAtrnPredicate(paymentJoin, criteriaBuilder, searchRequest.getAtrn()));
            }

            if (StringUtils.hasText(searchRequest.getOrderRefNumber())) {
                // orderRefNumber is in both entities, but prioritize payment if join exists
                if (paymentJoin != null) {
                    predicate = criteriaBuilder.and(predicate, getOrderRefNumberPredicate(paymentJoin, criteriaBuilder, searchRequest.getOrderRefNumber()));
                } else {
                    predicate = criteriaBuilder.and(predicate, getOrderRefNumberPredicate(root, criteriaBuilder, searchRequest.getOrderRefNumber()));
                }
            }

            if (StringUtils.hasText(searchRequest.getBankRefNumber())) {
                predicate = criteriaBuilder.and(predicate, getBankRefNumberPredicate(paymentJoin, criteriaBuilder, searchRequest.getBankRefNumber()));
            }

            if (StringUtils.hasText(searchRequest.getRefundStatus())) {
                predicate = criteriaBuilder.and(predicate, getRefundStatusPredicate(paymentJoin, criteriaBuilder, searchRequest.getRefundStatus()));
            }

            if (StringUtils.hasText(searchRequest.getTransactionStatus())) {
                predicate = criteriaBuilder.and(predicate, getTransactionStatusPredicate(paymentJoin, criteriaBuilder, searchRequest.getTransactionStatus()));
            }

            if (StringUtils.hasText(searchRequest.getPaymentStatus())) {
                predicate = criteriaBuilder.and(predicate, getPaymentStatusPredicate(paymentJoin, criteriaBuilder, searchRequest.getPaymentStatus()));
            }

            if (ObjectUtils.isNotEmpty(searchRequest.getFromDate())) {
                predicate = criteriaBuilder.and(predicate, getFromDatePredicate(paymentJoin, criteriaBuilder, searchRequest.getFromDate()));
            }

            if (ObjectUtils.isNotEmpty(searchRequest.getToDate())) {
                predicate = criteriaBuilder.and(predicate, getToDatePredicate(paymentJoin, criteriaBuilder, searchRequest.getToDate()));
            }

            if (StringUtils.hasText(searchRequest.getSbiOrderRefNumber())) {
                predicate = criteriaBuilder.and(predicate, getSbiOrderRefNumberPredicate(root, criteriaBuilder, searchRequest.getSbiOrderRefNumber()));
            }

            if (StringUtils.hasText(searchRequest.getOrderStatus())) {
                predicate = criteriaBuilder.and(predicate, getOrderStatusPredicate(root, criteriaBuilder, searchRequest.getOrderStatus()));
            }

            return predicate;
        };
    }

    private static Predicate getMidPredicate(Root<Order> root, CriteriaBuilder criteriaBuilder, String mId) {
        return criteriaBuilder.equal(root.get("mId"), mId);
    }

    private static Predicate getAtrnPredicate(Join<Order, MerchantOrderPayment> paymentJoin, CriteriaBuilder criteriaBuilder, String atrnNumber) {
        return criteriaBuilder.equal(paymentJoin.get("atrnNumber"), atrnNumber);
    }

    private static Predicate getOrderRefNumberPredicate(Path<?> path, CriteriaBuilder criteriaBuilder, String orderRefNumber) {
        return criteriaBuilder.equal(path.get("orderRefNumber"), orderRefNumber);
    }

    private static Predicate getBankRefNumberPredicate(Join<Order, MerchantOrderPayment> paymentJoin, CriteriaBuilder criteriaBuilder, String bankRefNumber) {
        return criteriaBuilder.equal(paymentJoin.get("bankReferenceNumber"), bankRefNumber);
    }

    private static Predicate getPaymentStatusPredicate(Join<Order, MerchantOrderPayment> paymentJoin, CriteriaBuilder criteriaBuilder, String status) {
        return criteriaBuilder.equal(paymentJoin.get("paymentStatus"), status);
    }

    private static Predicate getTransactionStatusPredicate(Join<Order, MerchantOrderPayment> paymentJoin, CriteriaBuilder criteriaBuilder, String status) {
        return criteriaBuilder.equal(paymentJoin.get("transactionStatus"), status);
    }

    private static Predicate getRefundStatusPredicate(Join<Order, MerchantOrderPayment> paymentJoin, CriteriaBuilder criteriaBuilder, String status) {
        return criteriaBuilder.equal(paymentJoin.get("refundStatus"), status);
    }

    private static Predicate getFromDatePredicate(Join<Order, MerchantOrderPayment> paymentJoin, CriteriaBuilder criteriaBuilder, Long fromDate) {
        return criteriaBuilder.greaterThanOrEqualTo(paymentJoin.get("createdDate"), fromDate);
    }

    private static Predicate getToDatePredicate(Join<Order, MerchantOrderPayment> paymentJoin, CriteriaBuilder criteriaBuilder, Long toDate) {
        return criteriaBuilder.lessThanOrEqualTo(paymentJoin.get("createdDate"), toDate);
    }

    private static Predicate getSbiOrderRefNumberPredicate(Root<Order> root, CriteriaBuilder criteriaBuilder, String sbiOrderRefNumber) {
        return criteriaBuilder.equal(root.get("sbiOrderRefNumber"), sbiOrderRefNumber);
    }

    private static Predicate getOrderStatusPredicate(Root<Order> root, CriteriaBuilder criteriaBuilder, String status) {
        return criteriaBuilder.equal(root.get("status"), status);
    }
}



@Service
public class TransactionService {
    private final OrderRepository orderRepository;

    @Autowired
    public TransactionService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    public List<Order> searchTransactions(String mId, MerchantOrderPaymentSearchRequest searchRequest) {
        if (StringUtils.isEmpty(mId)) {
            throw new IllegalArgumentException("Merchant ID is required");
        }
        if (searchRequest == null || isSearchRequestEmpty(searchRequest)) {
            throw new IllegalArgumentException("At least one search criterion is required");
        }

        Specification<Order> spec = OrderSpecification.searchOrder(mId, searchRequest);
        return orderRepository.findAll(spec);
    }

    // If you want to flatten to List<MerchantOrderPayment> instead:
    public List<MerchantOrderPayment> searchTransactionsFlattened(String mId, MerchantOrderPaymentSearchRequest searchRequest) {
        List<Order> orders = searchTransactions(mId, searchRequest);
        return orders.stream()
                     .flatMap(order -> order.getMerchantOrderPayments().stream())
                     .collect(Collectors.toList());
    }

    // isSearchRequestEmpty as before...
}