package com.epay.merchant.dao;

import com.epay.merchant.dto.AlertManagementDto;
import com.epay.merchant.dto.AlertMasterDto;
import com.epay.merchant.dto.ReportAlertDto;
import com.epay.merchant.entity.AlertManagement;
import com.epay.merchant.entity.AlertMaster;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.mapper.AlertMapper;
import com.epay.merchant.model.response.AlertManagementResponse;
import com.epay.merchant.repository.AlertManagementRepository;
import com.epay.merchant.repository.AlertMasterRepository;
import com.epay.merchant.util.MerchantConstant;
import org.apache.commons.collections4.CollectionUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AlertDaoTest {

    @Mock
    private AlertMasterRepository alertMasterRepository;

    @Mock
    private AlertManagementRepository alertManagementRepository;

    @Mock
    private MerchantInfoDao merchantInfoDao;

    @Mock
    private AlertMapper alertMapper;

    @InjectMocks
    private AlertDao alertDao;

    private AlertMasterDto alertMasterDto;
    private AlertMaster alertMaster;
    private AlertManagement alertManagement;
    private AlertManagementDto alertManagementDto;
    private ReportAlertDto reportAlertDto;

    @BeforeEach
    void setUp() {
        alertMaster = new AlertMaster();
        alertMaster.setId(UUID.randomUUID());
        alertMaster.setName(MerchantConstant.ACCOUNT_EXPIRY);
        alertMaster.setDescription("Your account will expire in {0} days.");

        alertMasterDto = new AlertMasterDto();
        alertMasterDto.setId(alertMaster.getId());
        alertMasterDto.setValue("7");
        alertMasterDto.setDescription(alertMaster.getDescription());

        alertManagement = new AlertManagement();
        alertManagement.setAlertId(alertMaster.getId());
        alertManagement.setMId("MID123");
        alertManagement.setAlertIdentifier(123456789012L);
        alertManagement.setAlertDescription("Account Expiry Alert");
        alertManagement.setIsViewed(false);

        alertManagementDto = new AlertManagementDto();
        alertManagementDto.setAlertId(alertMaster.getId());
        alertManagementDto.setMId("MID123");
        alertManagementDto.setAlertIdentifier("123456789012");
        alertManagementDto.setAlertDescription("Account Expiry Alert");

        reportAlertDto = new ReportAlertDto();
        reportAlertDto.setMId("MID123");
        reportAlertDto.setReportName("Daily Report");
    }

    @Test
    void shouldReturnLatest50UnreadAlertDescriptions() {
        when(alertManagementRepository.findAlertsByMId(eq("MID123"), any(PageRequest.class)))
                .thenReturn(List.of(alertManagement));
        when(alertMapper.alertManagementEntityToResponse(anyList()))
                .thenReturn(List.of(new AlertManagementResponse()));

        List<AlertManagementResponse> response = alertDao.getLatest50UnreadAlertDescription("MID123");

        assertNotNull(response);
        assertEquals(1, response.size());
        verify(alertManagementRepository, times(1)).findAlertsByMId(eq("MID123"), any(PageRequest.class));
    }

    @Test
    void shouldUpdateAlertViewStatus() {
        doNothing().when(alertManagementRepository).updateAlertViewStatus("MID123", 123456789012L);

        alertDao.updateViewStatus("MID123", 123456789012L);

        verify(alertManagementRepository, times(1)).updateAlertViewStatus("MID123", 123456789012L);
    }

    @Test
    void shouldSaveAllToAlertManagement() {
        when(alertMapper.mapDtoListToEntityList(anyList())).thenReturn(List.of(alertManagement));
        doNothing().when(alertManagementRepository).saveAll(anyList());

        alertDao.saveAllToAlertManagement(List.of(alertManagementDto));

        verify(alertManagementRepository, times(1)).saveAll(anyList());
    }

    @Test
    void shouldGetMIdsWithExpiryDays() {
        when(merchantInfoDao.getMIdsWithExpiryDays(anyList()))
                .thenReturn(Map.of("7", "MID123"));

        Map<String, String> result = alertDao.getMIdsWithExpiryDays(List.of("7"));

        assertFalse(result.isEmpty());
        assertEquals("MID123", result.get("7"));
        verify(merchantInfoDao, times(1)).getMIdsWithExpiryDays(anyList());
    }

    @Test
    void shouldFindAllAlertByName() {
        when(alertMasterRepository.findAllByName(MerchantConstant.ACCOUNT_EXPIRY))
                .thenReturn(List.of(alertMaster));
        when(alertMapper.mapAlertMasterEntityListToDtoList(anyList()))
                .thenReturn(List.of(alertMasterDto));

        List<AlertMasterDto> response = alertDao.findAllAlertByName(MerchantConstant.ACCOUNT_EXPIRY);

        assertNotNull(response);
        assertEquals(1, response.size());
        assertEquals("7", response.get(0).getValue());
        verify(alertMasterRepository, times(1)).findAllByName(MerchantConstant.ACCOUNT_EXPIRY);
    }

    @Test
    void shouldGenerateAlertForBankAccountApproval() {
        when(alertMasterRepository.findAllByName(MerchantConstant.BANK_ACCOUNT))
                .thenReturn(List.of(alertMaster));
        doNothing().when(alertManagementRepository).save(any(AlertManagement.class));

        alertDao.generateAlertForBankAccountApproval("MID123", "Bank of America");

        verify(alertMasterRepository, times(1)).findAllByName(MerchantConstant.BANK_ACCOUNT);
        verify(alertManagementRepository, times(1)).save(any(AlertManagement.class));
    }

    @Test
    void shouldFilterAlertsForUserRole() {
        List<UUID> excludeAlertIds = List.of(alertMaster.getId());
        List<AlertManagement> filteredAlerts = alertDao.filterAlertsForUserRole(List.of(alertManagement), excludeAlertIds);

        assertTrue(filteredAlerts.isEmpty());
    }

    @Test
    void shouldCollectAlertMasterIds() {
        List<UUID> ids = alertDao.collectAlertMasterId(List.of(alertMasterDto));

        assertEquals(1, ids.size());
        assertEquals(alertMaster.getId(), ids.get(0));
    }

    @Test
    void shouldGenerateAlertForReport() {
        when(alertMasterRepository.findByName(MerchantConstant.REPORT_GENERATION))
                .thenReturn(Optional.of(alertMaster));
        doNothing().when(alertManagementRepository).save(any(AlertManagement.class));

        alertDao.generateAlertForReport(reportAlertDto);

        verify(alertMasterRepository, times(1)).findByName(MerchantConstant.REPORT_GENERATION);
        verify(alertManagementRepository, times(1)).save(any(AlertManagement.class));
    }

    @Test
    void shouldThrowExceptionWhenReportAlertMasterNotFound() {
        when(alertMasterRepository.findByName(MerchantConstant.REPORT_GENERATION))
                .thenReturn(Optional.empty());

        MerchantException exception = assertThrows(MerchantException.class, () -> alertDao.generateAlertForReport(reportAlertDto));

        assertEquals("E0001", exception.getErrorCode());
        assertTrue(exception.getMessage().contains("Alert name  REPORT_GENERATION"));
        verify(alertMasterRepository, times(1)).findByName(MerchantConstant.REPORT_GENERATION);
    }
}