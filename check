 private void checkAndUpdateBulkRefundBooking(String bulkId) {
        BulkRefundBooking bulkRefundBooking = refundDao.findByBulkId(bulkId);
        List<BulkRefundBookingDetails> detailsList = refundDao.findAllByBulkId(bulkId);

        int totalRecords = bulkRefundBooking.getTotalRecords();
        int processedRecords = detailsList.size();
        int pendingRecords = (int) detailsList.stream()
                .filter(d -> RefundStatus.REFUND_IN_PROCESS.name().equals(d.getRefundStatus()))
                .count();

        // Update only when all rows are processed
        if (pendingRecords == 0 && processedRecords == totalRecords) {
            int validRecords = (int) detailsList.stream()
                    .filter(d -> RefundStatus.CANCELLATION_BOOKED.name().equals(d.getRefundStatus()))
                    .count();
            int invalidRecords = totalRecords - validRecords;

            bulkRefundBooking.setValidRecords(validRecords);
            bulkRefundBooking.setInvalidRecords(invalidRecords);
            bulkRefundBooking.setRemark(invalidRecords > 0 ? PARTIAL_PROCESS_MESSAGE : SUCCESS_PROCESS_MESSAGE);
            bulkRefundBooking.setBulkRefundStatus(BulkRefundStatus.PROCESSED.name());

            refundDao.saveBulkRefundBooking(bulkRefundBooking);
            logger.info("All rows processed, updated BulkRefundBooking: {} for bulkId: {}", bulkRefundBooking, bulkId);
        } else {
            logger.info("Not all rows processed yet for bulkId: {}. Total: {}, Processed: {}, Pending: {}",
                    bulkId, totalRecords, processedRecords, pendingRecords);
        }
    }





@EqualsAndHashCode(callSuper = true)
@Data
@Entity
@AllArgsConstructor
@NoArgsConstructor
@SuperBuilder
@Table(name = "BULK_REFUND_BOOKING")
public class BulkRefundBooking extends AuditEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    private String bulkId;
    private String merchantId;
    private String fileName;
    private String filePath;
    private Integer totalRecords;
    private Integer validRecords;
    private Integer invalidRecords;
    private String bulkRefundStatus;
    private String remark;

    /**
     * custom generator, do not remove it
     */
    @PrePersist
    protected void generateBulkId() {
        this.bulkId =  new StringBuilder().append(System.nanoTime()).reverse().append(this.merchantId, 2, 7).reverse().toString();
    }

}



@EqualsAndHashCode(callSuper = true)
@Data
@Entity
@AllArgsConstructor
@NoArgsConstructor
@SuperBuilder
@Table(name = "BULK_REFUND_BOOKING_DTLS")
public class BulkRefundBookingDetails extends AuditEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    private String bulkId;
    private Integer rowNumber;
    private String refundStatus;
    private String remark;

    private String refundType;
    private String merchantOrderId;
    private String atrn;
    private Double refundAmount;
    private String refundCurrency;
    private String comments;

}
