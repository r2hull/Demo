package com.epay.reporting.dao;

import com.epay.reporting.config.ReportingConfig;
import com.epay.reporting.dto.ReportScheduleManagementDto;
import com.epay.reporting.entity.ReportManagement;
import com.epay.reporting.entity.ReportScheduleManagement;
import com.epay.reporting.exception.ReportingException;
import com.epay.reporting.mapper.ReportScheduleManagementMapper;
import com.epay.reporting.model.request.ReportScheduleManagementSearchRequest;
import com.epay.reporting.model.request.ReportScheduleManagementUpdateRequest;
import com.epay.reporting.repository.ReportScheduleManagementRepository;
import com.epay.reporting.specification.ReportScheduleManagementSpecification;
import com.epay.reporting.util.DateTimeUtils;
import com.epay.reporting.util.ErrorConstants;
import com.epay.reporting.util.enums.Report;
import com.epay.reporting.util.enums.ReportScheduledStatus;
import com.epay.reporting.util.enums.ReportStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class ReportScheduleManagementDao {
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final ReportScheduleManagementRepository reportScheduleManagementRepository;
    private final ReportScheduleManagementMapper mapper;
    private final ReportMasterDao reportMasterDao;
    private final ReportManagementDao reportManagementDao;
    private final ReportingConfig reportingConfig;


   
    public void save(ReportScheduleManagementDto reportScheduleManagementDto) {
        log.info("Saving new report schedule for report: {}", reportScheduleManagementDto.getReport());
        UUID reportId = reportMasterDao.getReportIdByName(reportScheduleManagementDto.getReport());
        reportScheduleManagementDto.setReportId(reportId);
        reportScheduleManagementDto.setStatus(ReportScheduledStatus.TO_BE_START);
        reportScheduleManagementDto.setNextScheduleExecutionTime(DateTimeUtils.calculateDateByFrequency(reportScheduleManagementDto.getFrequency(), reportScheduleManagementDto.getScheduleExecutionTime()));
        ReportScheduleManagement reportScheduleManagement = mapper.mapDtoToEntity(reportScheduleManagementDto);
        reportScheduleManagementRepository.save(reportScheduleManagement);
        log.info("Report schedule saved successfully with ID: {}", reportScheduleManagement.getId());
    }
 
    public void executeReportBySchedule() {
        log.info("Executing reports by schedule.");
        Long scheduleEndTime = DateTimeUtils.addMinutes(reportingConfig.getReportScheduleExecutionWindow());
        List<ReportScheduleManagement> reportScheduleManagement = findByStatusAndNextScheduleExecutionTime(scheduleEndTime);
        List<ReportManagement> reportManagementList = reportScheduleManagement.stream().map(schedule -> {
            schedule.setLastScheduleExecutionTime(DateTimeUtils.getCurrentTimeInMills());
            schedule.setNextScheduleExecutionTime(DateTimeUtils.calculateDateByFrequency(schedule.getFrequency(), schedule.getScheduleExecutionTime()));
            return ReportManagement.builder().reportId(schedule.getReportId()).mId(schedule.getMId()).format(schedule.getFormat()).scheduledId(schedule.getId()).durationFromDate(DateTimeUtils.calculateBackDateByFrequency(schedule.getFrequency(), scheduleEndTime)).durationToDate(DateTimeUtils.getCurrentTimeInMills()).scheduledId(schedule.getId()).status(ReportStatus.TO_BE_GENERATE).build();
        }).toList();
        reportScheduleManagementRepository.saveAll(reportScheduleManagement);
        reportManagementDao.saveAll(reportManagementList);
        log.info("Reports executed and saved successfully.");
    }

    
    public Page<ReportScheduleManagementDto> searchAndGetAll(ReportScheduleManagementSearchRequest searchRequest, Pageable pageable) {
        log.info("Searching for report schedules with request: {}", searchRequest);
        UUID reportId = null;
        if (ObjectUtils.isNotEmpty(searchRequest.getReport())) {
            reportId = reportMasterDao.getReportIdByName(Report.getName(searchRequest.getReport()));
        }
        Specification<ReportScheduleManagement> specification = ReportScheduleManagementSpecification.searchSchedulerManagement(reportId, searchRequest);
        return reportScheduleManagementRepository.findAll(specification, pageable).map(this::convertEntityToDTO);
    }

   
    public void update(UUID id, ReportScheduleManagementUpdateRequest request) {
        log.info("Updating report schedule with ID: {}", id);
        ReportScheduleManagement reportScheduleManagement = reportScheduleManagementRepository.findById(id).orElseThrow(() -> new ReportingException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, ErrorConstants.SCHEDULE_REQUEST_ID)));
        mergeNonNullFields(reportScheduleManagement, request);
        reportScheduleManagementRepository.save(reportScheduleManagement);
        log.info("Report schedule with ID: {} updated successfully.", id);
    }

    
    public void cancelScheduler(UUID id) {
        log.info("Canceling report schedule with ID: {}", id);
        ReportScheduleManagement reportScheduleManagement = reportScheduleManagementRepository.findById(id).orElseThrow(() -> new ReportingException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, ErrorConstants.SCHEDULE_REQUEST_ID)));
        reportScheduleManagement.setStatus(ReportScheduledStatus.CANCELLED);
        reportScheduleManagement.setNextScheduleExecutionTime(null);
        reportScheduleManagementRepository.save(reportScheduleManagement);
        log.info("Report schedule with ID: {} canceled successfully.", id);
    }
    
    private List<ReportScheduleManagement> findByStatusAndNextScheduleExecutionTime(long scheduleEndTime) {
        log.info("Finding report schedules to be executed with status: {} and next execution time before: {}", ReportScheduledStatus.TO_BE_START, scheduleEndTime);
        // TODO : Spring Batch need to user here
        return reportScheduleManagementRepository.findByStatusAndNextScheduleExecutionTime(ReportScheduledStatus.TO_BE_START, scheduleEndTime);
    }

   
    private ReportScheduleManagementDto convertEntityToDTO(ReportScheduleManagement reportScheduleManagement) {
        ReportScheduleManagementDto reportScheduleManagementDto = mapper.mapEntityToDto(reportScheduleManagement);
        reportScheduleManagementDto.setReport(reportMasterDao.getReportNameById(reportScheduleManagementDto.getReportId()));
        return reportScheduleManagementDto;
    }
    
    private void mergeNonNullFields(ReportScheduleManagement reportScheduleManagement, ReportScheduleManagementUpdateRequest request) {
        Optional.ofNullable(request.getFormat()).ifPresent(reportScheduleManagement::setFormat);
        Optional.ofNullable(request.getFrequency()).ifPresent(reportScheduleManagement::setFrequency);
        Optional.ofNullable(request.getScheduleExecutionTime()).ifPresent(reportScheduleManagement::setScheduleExecutionTime);
    }
}
