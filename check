@Data
public class KeyGenerationRequest {
    @NotEmpty(message = MANDATORY_ERROR_MESSAGE)
    private String mId;
    private SecretKeyLength keyLength;//This is for encryption
    private int expiry; //in hrs
    @Min(value = 1, message = MIN_VALUE_ERROR_MESSAGE + MIN_VAL_NEW_KEY_EXPIRY_TIME)
    private int newKeyExpiryTime;
}




@ControllerAdvice
public class KMSExceptionHandler {
    LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    @ExceptionHandler(value = {KeyManagementException.class})
    public ResponseEntity<Object> handleKMSException(KeyManagementException ex) {
        ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    @ExceptionHandler(value = {EncryptionDecryptionException.class})
    public ResponseEntity<Object> handleEncryptionDecryptionException(EncryptionDecryptionException ex) {
        ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
        return generateResponseWithErrors(List.of(errorDto));
    }

  
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<Object> handleValidationException(ValidationException ex) {
        logger.error("Handling ValidationException: {}", ex.getMessage(), ex);
        if (CollectionUtils.isEmpty(ex.getErrorMessages())) {
            ErrorDto errorDto = ErrorDto.builder().errorCode(ex.getErrorCode()).errorMessage(ex.getErrorMessage()).build();
            return generateResponseWithErrors(List.of(errorDto));
        }
        return generateResponseWithErrors(ex.getErrorMessages());
    }
 
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<Object> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        logger.error("Error in handleMethodArgumentTypeMismatch with message: {}", ex.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(UNCATEGORIZED_ERROR_CODE)
                .errorMessage(UNCATEGORIZED_ERROR_MESSAGE)
                .build();
        return generateResponseWithErrors(List.of(errorDto));
    }

    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<Object> handleResourceException(NoResourceFoundException ex) {
        logger.error("Error in handleResourceException for resource: {}, message: {}", ex.getResourcePath(), ex.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(UNCATEGORIZED_ERROR_CODE)
                .errorMessage(UNCATEGORIZED_ERROR_MESSAGE).build();
        return ResponseEntity.status(HttpStatus.OK).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    @ExceptionHandler(value = {Exception.class})
    public ResponseEntity<Object> handleGenericException(Exception ex) {
        logger.error("Error in handleGenericException ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(UNCATEGORIZED_ERROR_CODE).errorMessage(UNCATEGORIZED_ERROR_MESSAGE).build();
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    @ExceptionHandler(value = {MethodArgumentNotValidException.class})
    protected ResponseEntity<Object> handleValidationException(MethodArgumentNotValidException ex) {
        logger.error("Error in handleValidationException with message: {}", ex.getMessage());
        List<ErrorDto> errors = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(fieldError -> addErrorDto(errors, fieldError));
        return ResponseEntity.status(HttpStatus.OK).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(errors).build());
    }

    private void addErrorDto(List<ErrorDto> errors, FieldError fieldError) {
        String errCd = MANDATORY_ERROR_CODE;
        String errMsg = fieldError.getDefaultMessage();
        if(StringUtils.equalsIgnoreCase(MIN_VALUE_ERROR_MESSAGE, errMsg)) {
            errCd = MIN_VALUE_ERROR_CODE;
        }
        errors.add(ErrorDto.builder().errorCode(errCd)
                .errorMessage(MessageFormat.format(Objects.requireNonNull(errMsg), fieldError.getField())).build());
    }

    @ExceptionHandler(value = {IllegalArgumentException.class})
    protected ResponseEntity<Object> handleConflict(RuntimeException ex) {
        logger.error("Error in handleConflict ", ex);
        ErrorDto errorDto = ErrorDto.builder().errorCode(UNCATEGORIZED_ERROR_CODE).errorMessage(UNCATEGORIZED_ERROR_MESSAGE).build();
        return ResponseEntity.status(HttpStatus.CONFLICT).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

    private ResponseEntity<Object> generateResponseWithErrors(List<ErrorDto> errors) {
        return ResponseEntity.ok().body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(errors).build());
    }

   
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<Object> handleEnumConversionException(HttpMessageNotReadableException e) {
        logger.error("Error in handleEnumConversionException with message: {}", e.getMessage());
        ErrorDto errorDto = ErrorDto.builder().errorCode(JSON_ERROR_CODE).errorMessage(MessageFormat.format(JSON_ERROR_MESSAGE, REQUEST_BODY)).build();
        return generateResponseWithErrors(List.of(errorDto));
    }


    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<Object> handleHttpRequestMethodNotSupportedException(HttpRequestMethodNotSupportedException ex) {
        logger.error("Error in handleHttpRequestMethodNotSupportedException for resource: {}",ex.getMessage());
        ErrorDto errorDto = ErrorDto.builder()
                .errorCode(UNCATEGORIZED_ERROR_CODE)
                .errorMessage(UNCATEGORIZED_ERROR_MESSAGE)
                .build();
        return ResponseEntity.status(HttpStatus.OK).body(KMSResponse.builder().status(RESPONSE_FAILURE).errors(List.of(errorDto)).build());
    }

}
