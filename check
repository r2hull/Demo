import com.epay.merchant.dao.CaptchaDao;
import com.epay.merchant.dto.ErrorDto;
import com.epay.merchant.entity.cache.CaptchaManagement;
import com.epay.merchant.model.request.CaptchaRequest;
import com.epay.merchant.util.DateTimeUtils;
import com.epay.merchant.util.ErrorConstants;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CaptchaValidatorTest {

    @InjectMocks
    private CaptchaValidator captchaValidator;

    @Mock
    private CaptchaDao captchaDao;

    private UUID requestId;
    private CaptchaRequest captchaRequest;
    private CaptchaManagement captchaManagement;

    @BeforeEach
    void setUp() {
        requestId = UUID.randomUUID();
        captchaRequest = new CaptchaRequest();
        captchaRequest.setRequestId(requestId);
        captchaRequest.setRequestType("LOGIN");

        captchaManagement = new CaptchaManagement();
        captchaManagement.setExpiryTime(LocalDateTime.now().plusMinutes(5));
        captchaManagement.setCaptchaText("123456");
    }

    @Test
    void requestValidator_ShouldPassValidation_WhenValidRequest() {
        when(captchaDao.existsByRequestId(any())).thenReturn(false);

        assertDoesNotThrow(() -> captchaValidator.requestValidator(captchaRequest));
    }

    @Test
    void requestValidator_ShouldFail_WhenDuplicateRequestId() {
        when(captchaDao.existsByRequestId(requestId)).thenReturn(true);

        Exception exception = assertThrows(RuntimeException.class, () -> captchaValidator.requestValidator(captchaRequest));
        assertTrue(exception.getMessage().contains("Duplicate RequestId"));
    }

    @Test
    void regenerateValidator_ShouldPass_WhenValidRequest() {
        when(captchaDao.existsByRequestId(requestId)).thenReturn(true);

        assertDoesNotThrow(() -> captchaValidator.regenerateValidator(captchaRequest));
    }

    @Test
    void regenerateValidator_ShouldFail_WhenRequestIdNotFound() {
        when(captchaDao.existsByRequestId(requestId)).thenReturn(false);

        Exception exception = assertThrows(RuntimeException.class, () -> captchaValidator.regenerateValidator(captchaRequest));
        assertTrue(exception.getMessage().contains("RequestId"));
    }

    @Test
    void captchaValueValidation_ShouldPass_WhenCaptchaMatchesAndNotExpired() {
        when(captchaDao.getActiveCaptchaByRequestId(requestId)).thenReturn(captchaManagement);
        when(DateTimeUtils.isPastDate(any())).thenReturn(false);

        assertDoesNotThrow(() -> captchaValidator.captchaValueValidation(requestId, "123456"));
    }

    @Test
    void captchaValueValidation_ShouldFail_WhenCaptchaExpired() {
        when(captchaDao.getActiveCaptchaByRequestId(requestId)).thenReturn(captchaManagement);
        when(DateTimeUtils.isPastDate(any())).thenReturn(true);

        Exception exception = assertThrows(RuntimeException.class, () -> captchaValidator.captchaValueValidation(requestId, "123456"));
        assertTrue(exception.getMessage().contains("expired"));
    }

    @Test
    void captchaValueValidation_ShouldFail_WhenCaptchaDoesNotMatch() {
        when(captchaDao.getActiveCaptchaByRequestId(requestId)).thenReturn(captchaManagement);
        when(DateTimeUtils.isPastDate(any())).thenReturn(false);

        Exception exception = assertThrows(RuntimeException.class, () -> captchaValidator.captchaValueValidation(requestId, "654321"));
        assertTrue(exception.getMessage().contains("Captcha"));
    }

    @Test
    void isCaptchaVerifiedValidation_ShouldPass_WhenCaptchaIsVerified() {
        when(captchaDao.existByRequestIdAndVerified(requestId)).thenReturn(true);

        assertDoesNotThrow(() -> captchaValidator.isCaptchaVerifiedValidation(requestId));
    }

    @Test
    void isCaptchaVerifiedValidation_ShouldFail_WhenCaptchaIsNotVerified() {
        when(captchaDao.existByRequestIdAndVerified(requestId)).thenReturn(false);

        Exception exception = assertThrows(RuntimeException.class, () -> captchaValidator.isCaptchaVerifiedValidation(requestId));
        assertTrue(exception.getMessage().contains("not verified"));
    }

}