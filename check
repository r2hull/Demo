@Getter
public class MerchantException extends RuntimeException {
    private String errorCode;
    private String errorMessage;
    private List<ErrorDto> errorMessages;

    public MerchantException(String errorCode, String errorMessage) {
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }

    public MerchantException(List<ErrorDto> errorMessages) {
        this.errorMessages = errorMessages;
    }

}

 @ExceptionHandler(value = {MerchantException.class, EncryptionDecryptionException.class})
    public ResponseEntity<Object> handleEPayServiceException(RuntimeException ex) {
        logger.error("Handling MerchantException or EncryptionDecryptionException: {}", ex.getMessage(), ex);
        ErrorDto errorDto;
        switch (ex) {
            case MerchantException me ->
                    errorDto = ErrorDto.builder().errorCode(me.getErrorCode()).errorMessage(me.getErrorMessage()).build();
            case EncryptionDecryptionException me ->
                    errorDto = ErrorDto.builder().errorCode(me.getErrorCode()).errorMessage(me.getErrorMessage()).build();
            default ->
                    errorDto = ErrorDto.builder().errorCode(ErrorConstants.GENERIC_ERROR_CODE).errorMessage(ex.getLocalizedMessage()).build();
        }
        return generateResponseWithErrors(List.of(errorDto));
    }
